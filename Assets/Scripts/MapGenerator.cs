using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Mirror;
using UnityEngine;
using UnityEngine.Networking;
using MathNet.Numerics;
using System;

public class MapGenerator : NetworkBehaviour
{
	// 0 = spawn, 1 = top, 2 = left, 3 = right
	public int numTiles = 12;
	public float numTilesMaximumVariation = 3;
	public int tileEdgeSize = 20;

	public GameObject startTile;
	public GameObject endTile;

	public GameObject[] straightTiles;
	public GameObject[] cornerTiles;

	[Tooltip("Used to force a specific random seed value for debugging purposes")]
	public int DEBUG_ForceSeed = 0;

	private bool Generated = false;

	private const string url = "https://docs.google.com/spreadsheets/d/1oyn2qrTV5vgCidw-L69JlHLH4p0i1uyGnA899FeR67g/export?format=csv";

	private Vector3Int currLocation = new Vector3Int(0, 0, 0);

	private GameObject newTile;
	private int[] validOptions;
	private int randDirection = 1;
	private int randTile;

	private int idealLength;

	// 0 = spawn, 1 = top, 2 = left, 3 = right
	private List<int> path = new List<int>() { 0 };
	private List<Vector3Int> locations = new List<Vector3Int>() { new Vector3Int(0, 0, 0) };

	public event System.Action OnUserDataLoaded;

	public override void OnStartServer()
	{
		base.OnStartServer();
		Physics.autoSimulation = false; // TODO: There's probably a much better way of delaying spawning. But this will do for now.
		OnUserDataLoaded += OnGetComplete;
		StartCoroutine(GetUserData());

	}

	void OnGetComplete()
	{
		int ServerSeed = DEBUG_ForceSeed;

		if (ServerSeed == 0)
		{
			ServerSeed = UnityEngine.Random.Range(1, 1337);
		}

		Debug.Log("Calling Spawn with seed: " + ServerSeed);
		if (!Generated) {
			Spawn(ServerSeed);
			//Generated = true;
		}

		Physics.autoSimulation = true;
	}


	[Server]
	void Spawn(int Seed)
	{
		Debug.Log("Spawning Level...");
		UnityEngine.Random.InitState(Seed);

		System.Random systemRand = new System.Random();

		double randGaus = RandomGaussian(systemRand, idealLength, numTilesMaximumVariation/2);

		numTiles = Mathf.RoundToInt((float)randGaus);
		Debug.Log("random map length is " + numTiles);

		// Save length of map in order to post to google forms later
		PlayerPrefs.SetInt("numTiles", numTiles);
		PlayerPrefs.Save();

		// Until we reach the maximum number of tiles on the map
		for (int i = 0; i < numTiles; i++)
		{

			// First we check what the available options for the next tile placements are, based on whether the current tile was
			// generated by moving forward, left, or right
			switch (path[path.Count - 1])
			{
				// first tile after spawn will always be placed forward
				case 0:
					randDirection = 1;
					break;

				// Last move was forward
				case 1:
					validOptions = new int[3] { 1, 2, 3 };
					randDirection = validOptions[UnityEngine.Random.Range(0, validOptions.Length)];
					break;

				// Last move was to the left
				case 2:
					validOptions = new int[2] { 1, 2 };
					randDirection = validOptions[UnityEngine.Random.Range(0, validOptions.Length)];
					break;

				// Last move was to the right
				case 3:
					validOptions = new int[2] { 1, 3 };
					randDirection = validOptions[UnityEngine.Random.Range(0, validOptions.Length)];
					break;
			}

			// Next, we choose a random direction and add a new location to the locations array
			switch (randDirection)
			{

				// Add tile forward
				case 1:
					currLocation = new Vector3Int(currLocation.x + tileEdgeSize, currLocation.y, currLocation.z);
					locations.Add(currLocation);
					path.Add(1);
					break;

				// Add tile to the left
				case 2:
					currLocation = new Vector3Int(currLocation.x, currLocation.y, currLocation.z - tileEdgeSize);
					locations.Add(currLocation);
					path.Add(2);
					break;

				// Add tile to the right
				case 3:
					currLocation = new Vector3Int(currLocation.x, currLocation.y, currLocation.z + tileEdgeSize);
					locations.Add(currLocation);
					path.Add(3);
					break;
			}
			//Debug.Log("Spawning tile number " + (i+1) + " at " + currLocation.x + "," + currLocation.z);
		}
		// Finally, we go through each of the spawn points, checking what is in front of and behind them, and
		// instantiate a suitable tile at that location

		// The value at path[i] means that the position of current tile (i) was created by moving 1/forward, 2/left, or 3/right
		for (int i = 0; i < locations.Count; i++)
		{
			if (i == 0)
			{
				NetworkServer.Spawn(Instantiate(startTile, locations[i], startTile.transform.rotation));
			}
			else if (i == locations.Count - 1)
			{
				// For the last tile generated, we don't care about the forward direction, just the previous one
				newTile = Instantiate(endTile, locations[i], Quaternion.identity);
				if (path[i] == 1)
				{
					newTile.transform.Rotate(0, 90, 0, Space.World);
				}
				NetworkServer.Spawn(newTile);
			}
			else
			{
				// All medial tiles
				if (path[i] == path[i + 1] && path[i] == 1)
				{
					// Path is in a straight vertical line
					randTile = UnityEngine.Random.Range(0, straightTiles.Length);
					newTile = Instantiate(straightTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
					newTile.transform.Rotate(0, 90, 0, Space.World);
				}
				else if (path[i] == path[i + 1] && path[i] != 1)
				{
					// Path is in a straight horizontal line (left or right)
					randTile = UnityEngine.Random.Range(0, straightTiles.Length);
					newTile = Instantiate(straightTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
				}
				else if (path[i] == 1 && path[i + 1] == 2)
				{
					// Path is a corner, was heading straight and now left
					randTile = UnityEngine.Random.Range(0, cornerTiles.Length);
					newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
				}
				else if (path[i] == 1 && path[i + 1] == 3)
				{
					// Path is a corner, was heading straight and now right
					randTile = UnityEngine.Random.Range(0, cornerTiles.Length);
					newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
					newTile.transform.Rotate(0, 90, 0, Space.World);
				}
				else if (path[i] == 2 && path[i + 1] == 1)
				{
					// Path is a corner, was heading left and now straight
					randTile = UnityEngine.Random.Range(0, cornerTiles.Length);
					newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
					newTile.transform.Rotate(0, 180, 0, Space.World);
				}
				else if (path[i] == 3 && path[i + 1] == 1)
				{
					// Path is a corner, was heading right and now straights
					randTile = UnityEngine.Random.Range(0, cornerTiles.Length);
					newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
					newTile.transform.Rotate(0, 270, 0, Space.World);
				}

				NetworkServer.Spawn(newTile);
			}
		}
	}

	IEnumerator GetUserData()
	{
		UnityWebRequest userData = UnityWebRequest.Get(url);
		//userData.useHttpContinue = false;
		//userData.downloadHandler = new DownloadHandlerBuffer();
		yield return userData.SendWebRequest();

		if (userData.isNetworkError || userData.isHttpError)
		{
			Debug.Log(userData.error);
		}

		ParseCSV(userData);
		OnUserDataLoaded?.Invoke();
	}

	void ParseCSV(UnityWebRequest req)
	{
		//Debug.Log("Data before parsing: " + req.downloadHandler.text);

		string fullText = req.downloadHandler.text;
		List<double> lengthData = new List<double>();
		List<double> funData = new List<double>();

		// Split into lines.
		fullText = fullText.Replace('\n', '\r');
		string[] lines = fullText.Split(new char[] { '\r' },
			System.StringSplitOptions.RemoveEmptyEntries);

		// Skip first line, which contains column labels
		lines = lines.Skip(1).ToArray();

		// Parse each lines at the commas
		foreach (string line in lines)
		{
			string[] entries = line.Split(',');

			double lengthVal = (double)System.Int32.Parse(entries[2]);
			double funVal = (double)System.Int32.Parse(entries[1]);

			lengthData.Add(lengthVal);
			funData.Add(funVal);
		}

		double[] lengthDataArr = lengthData.ToArray();
		double[] funDataArr = funData.ToArray();

		CalculateIdealLength(lengthDataArr, funDataArr);
	}

	void CalculateIdealLength(double[] length, double[] fun)
	{
		//double[] length = new double[] { 10, 20, 30 };
		//double[] fun = new double[] { 15, 20, 25 };

		var polyFit = Polynomial.Fit(length, fun, 2);

		double vertex = polyFit.Evaluate(-polyFit.Coefficients[1] / (2 * polyFit.Coefficients[2]));

		Debug.Log("data shows that maximum fun is achieved at length of: " + Mathf.RoundToInt((float)vertex));

		idealLength = Mathf.RoundToInt((float)vertex);
	}

	public static double RandomGaussian(System.Random random, double mean, double stddev)
	{
		// The method requires sampling from a uniform random of (0,1]
		// but Random.NextDouble() returns a sample of [0,1).
		double x1 = 1 - random.NextDouble();
		double x2 = 1 - random.NextDouble();

		double y1 = Math.Sqrt(-2.0 * Math.Log(x1)) * Math.Cos(2.0 * Math.PI * x2);
		return y1 * stddev + mean;
	}
}
