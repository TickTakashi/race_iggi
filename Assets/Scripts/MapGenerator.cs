using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MapGenerator : MonoBehaviour {

    // 0 = spawn, 1 = top, 2 = left, 3 = right

    public int numTiles = 12;
    public int tileEdgeSize = 20;

    public GameObject startTile;
    public GameObject endTile;

    public GameObject[] straightTiles;
    public GameObject[] cornerTiles;

    private Vector3Int currLocation = new Vector3Int(0, 0, 0);

    private GameObject newTile;
    private int[] validOptions;
    private int randDirection;
    private int randTile;

    // 0 = spawn, 1 = top, 2 = left, 3 = right
    private List<int> path = new List<int>() { 0 };
    private List<Vector3Int> locations = new List<Vector3Int>() { new Vector3Int(0, 0, 0) };

    void Start()
    {
        //endLocation = new Vector3(Random.Range(5, 10), Random.Range(5, 10), 0);
        //options = GameObject.FindGameObjectWithTag("tiles").GetComponent<TileOptions>();
        Invoke("Spawn", 1.0f);
    }

    void Spawn()
    {
        // Until we reach the maximum number of tiles on the map
        for (int i = 0; i < numTiles; i++)  
        {

            // First we check what the available options for the next tile placements are, based on whether the current tile was
            // generated by moving forward, left, or right
            switch (path[path.Count - 1])
            {
                // No move, first tile
                case 0:
                    validOptions = new int[3] { 1, 2, 3 };
                    randDirection = validOptions[Random.Range(0, validOptions.Length)];
                    break;

                // Last move was forward
                case 1:
                    validOptions = new int[3] { 1, 2, 3 };
                    randDirection = validOptions[Random.Range(0, validOptions.Length)];
                    break;

                // Last move was to the left
                case 2:
                    validOptions = new int[2] { 1, 2 };
                    randDirection = validOptions[Random.Range(0, validOptions.Length)];
                    break;

                // Last move was to the right
                case 3:
                    validOptions = new int[2] { 1, 3 };
                    randDirection = validOptions[Random.Range(0, validOptions.Length)];
                    break;
            }
           
            // Next, we choose a random direction and add a new location to the locations array
            switch (randDirection)
            {

                // Add tile forward
                case 1:
                    currLocation = new Vector3Int(currLocation.x + tileEdgeSize, currLocation.y, currLocation.z);
                    locations.Add(currLocation);
                    path.Add(1);
                    break;

                // Add tile to the left
                case 2:
                    currLocation = new Vector3Int(currLocation.x, currLocation.y, currLocation.z - tileEdgeSize);
                    locations.Add(currLocation);
                    path.Add(2);
                    break;

                // Add tile to the right
                case 3:
                    currLocation = new Vector3Int(currLocation.x, currLocation.y, currLocation.z + tileEdgeSize);
                    locations.Add(currLocation);
                    path.Add(3);
                    break;
            }
            //Debug.Log("Spawning tile number " + (i+1) + " at " + currLocation.x + "," + currLocation.z);
        }
        // Finally, we go through each of the spawn points, checking what is in front of and behind them, and
        // instantiate a suitable tile at that location

        // The value at path[i] means that the position of current tile (i) was created by moving 1/forward, 2/left, or 3/right
        for (int i = 0; i < locations.Count; i++)
        {
            if (i == 0)
            {
                Instantiate(startTile, locations[i], Quaternion.identity);
            }

            // For the last tile generated, we don't care about the forward direction
            else if (i == locations.Count - 1)
            {
                Instantiate(endTile, locations[i], Quaternion.identity);
            }

            // All medial tiles
            else
            {
                // Path is in a straight vertical line
                if (path[i] == path[i + 1] && path[i] == 1)
                {
                    randTile = Random.Range(0, straightTiles.Length);
                    newTile = Instantiate(straightTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
                    newTile.transform.Rotate(0, 90, 0, Space.World);
                }

                // Path is in a straight horizontal line (left or right)
                else if (path[i] == path[i + 1] && path[i] != 1)
                {
                    randTile = Random.Range(0, straightTiles.Length);
                    newTile = Instantiate(straightTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
                    //newTile.transform.Rotate(0, 90, 0, Space.World);
                    //Debug.Log("why u no rotate");
                }

                // Path is a corner, was heading straight and now left
                else if (path[i] == 1 && path[i + 1] == 2)
                {
                    randTile = Random.Range(0, cornerTiles.Length);
                    newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
                }

                // Path is a corner, was heading straight and now right
                else if (path[i] == 1 && path[i + 1] == 3)
                {
                    randTile = Random.Range(0, cornerTiles.Length);
                    newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
                    newTile.transform.Rotate(0, 90, 0, Space.World);
                }

                // Path is a corner, was heading left and now straight
                else if (path[i] == 2 && path[i + 1] == 1)
                {
                    randTile = Random.Range(0, cornerTiles.Length);
                    newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
                    newTile.transform.Rotate(0, 180, 0, Space.World);
                }

                // Path is a corner, was heading right and now straight
                else if (path[i] == 3 && path[i + 1] == 1)
                {
                    randTile = Random.Range(0, cornerTiles.Length);
                    newTile = Instantiate(cornerTiles[randTile], locations[i], straightTiles[randTile].transform.rotation);
                    newTile.transform.Rotate(0, 270, 0, Space.World);
                }
            }
        }
    }
}
